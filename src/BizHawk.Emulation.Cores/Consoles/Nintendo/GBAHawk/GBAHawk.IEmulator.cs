using BizHawk.Emulation.Common;
using System;
using System.Text;

namespace BizHawk.Emulation.Cores.Nintendo.GBA
{
	public partial class GBAHawk : IEmulator, ISoundProvider, IVideoProvider
	{
		public IEmulatorServiceProvider ServiceProvider { get; }

		public ControllerDefinition ControllerDefinition => current_controller;

		public bool FrameAdvance(IController controller, bool render, bool rendersound)
		{
			ushort cont_result = 0x3FF;

			if (controller.IsPressed("Up"))
			{
				cont_result &= 0xFFBF;
			}
			if (controller.IsPressed("Down"))
			{
				cont_result &= 0xFF7F;
			}
			if (controller.IsPressed("Left"))
			{
				cont_result &= 0xFFDF;
			}
			if (controller.IsPressed("Right"))
			{
				cont_result &= 0xFFEF;
			}
			if (controller.IsPressed("Start"))
			{
				cont_result &= 0xFFF7;
			}
			if (controller.IsPressed("Select"))
			{
				cont_result &= 0xFFFB;
			}
			if (controller.IsPressed("B"))
			{
				cont_result &= 0xFFFD;
			}
			if (controller.IsPressed("A"))
			{
				cont_result &= 0xFFFE;
			}
			if (controller.IsPressed("L"))
			{
				cont_result &= 0xFDFF;
			}
			if (controller.IsPressed("R"))
			{
				cont_result &= 0xFEFF;
			}

			if (mapper == 3)
			{
				theta_prev = theta;
				phi_prev_2 = phi_prev;
				phi_prev = phi;

				theta = (float)(controller.AxisValue("P1 Tilt Y") * Math.PI / 180.0);
				phi = (float)(controller.AxisValue("P1 Tilt X") * Math.PI / 180.0);

				// acc x is the result of rotating around body y AFTER rotating around body x
				// therefore this control scheme gives decreasing sensitivity in X as Y rotation increases
				var temp = (float)(Math.Cos(theta) * Math.Sin(phi));
				// additional acceleration components are dominated by axial components due to off axis rotation.
				// They vary widely based on physical hand movements, but this roughly matches what I observe in a real GBP
				var temp2 = (float)((phi - 2 * phi_prev + phi_prev_2) * 59.7275 * 59.7275 * 0.1);
				accX = (ushort)(0x3A0 - Math.Floor(temp * 256) - temp2);

				// acc y is just the sine of the angle
				var temp3 = (float)Math.Sin(theta);
				// here we add in the acceleration generated by the point of rotation being far away from the accelerometer
				// this term dominates other facators due to the cartridge being far from the players hands in whatever system is being used.
				// It roughly matches what I observe in a real GBP
				var temp4 = (float)(Math.Pow((theta - theta_prev) * 59.7275, 2) * 0.15);
				accY = (ushort)(0x3A0 - Math.Floor(temp3 * 256) + temp4);
			}

			if (Tracer.IsEnabled())
			{
				tracecb = MakeTrace;
			}
			else
			{
				tracecb = null;
			}
			
			LibGBAHawk.GBA_settracecallback(GBA_Pntr, tracecb);

			if (controller.IsPressed("Power"))
			{
				HardReset();
			}

			_isLag = LibGBAHawk.GBA_frame_advance(GBA_Pntr, cont_result, accX, accY, true, true);

			LibGBAHawk.GBA_get_video(GBA_Pntr, _vidbuffer);

			_frame++;

			return true;
		}

		public int Frame => _frame;

		public string SystemId => VSystemID.Raw.GBA;

		public bool DeterministicEmulation => true;

		public void ResetCounters()
		{
			_frame = 0;
			_lagCount = 0;
			_isLag = false;
		}

		public void Dispose()
		{
			if (GBA_Pntr != IntPtr.Zero)
			{
				LibGBAHawk.GBA_destroy(GBA_Pntr);
				GBA_Pntr = IntPtr.Zero;
			}

			DisposeSound();
		}

		public BlipBuffer blip_L = new BlipBuffer(25000);
		public BlipBuffer blip_R = new BlipBuffer(25000);

		public int[] Aud_L = new int[25000];
		public int[] Aud_R = new int[25000];
		public uint num_samp_L;
		public uint num_samp_R;

		const int blipbuffsize = 9000;

		public bool CanProvideAsync => false;

		public void SetSyncMode(SyncSoundMode mode)
		{
			if (mode != SyncSoundMode.Sync)
			{
				throw new NotSupportedException("Only sync mode is supported");
			}
		}

		public void GetSamplesAsync(short[] samples)
		{
			throw new NotSupportedException("Async not supported");
		}

		public SyncSoundMode SyncMode => SyncSoundMode.Sync;

		public void GetSamplesSync(out short[] samples, out int nsamp)
		{
			uint f_clock = LibGBAHawk.GBA_get_audio(GBA_Pntr, Aud_L, ref num_samp_L, Aud_R, ref num_samp_R);

			for (int i = 0; i < num_samp_L; i++)
			{
				blip_L.AddDelta((uint)Aud_L[i * 2], Aud_L[i * 2 + 1]);
			}

			for (int i = 0; i < num_samp_R; i++)
			{
				blip_R.AddDelta((uint)Aud_R[i * 2], Aud_R[i * 2 + 1]);
			}

			//Console.WriteLine(num_samp_L + " " + num_samp_R + " " + f_clock);

			blip_L.EndFrame(f_clock);
			blip_R.EndFrame(f_clock);

			nsamp = blip_L.SamplesAvailable();
			samples = new short[nsamp * 2];

			if (nsamp != 0)
			{
				blip_L.ReadSamplesLeft(samples, nsamp);
				blip_R.ReadSamplesRight(samples, nsamp);
			}
		}

		public void DiscardSamples()
		{
			blip_L.Clear();
			blip_R.Clear();
		}

		public void DisposeSound()
		{
			blip_L.Clear();
			blip_R.Clear();
			blip_L.Dispose();
			blip_R.Dispose();
			blip_L = null;
			blip_R = null;
		}

		public int[] _vidbuffer = new int[240 * 160];

		public int[] GetVideoBuffer()
		{
			return _vidbuffer;
		}

		public int VirtualWidth => 240;
		public int VirtualHeight => 160;
		public int BufferWidth => 240;
		public int BufferHeight => 160;
		public int BackgroundColor => unchecked((int)0xFF000000);
		public int VsyncNumerator => 262144;
		public int VsyncDenominator => 4389;
	}
}
